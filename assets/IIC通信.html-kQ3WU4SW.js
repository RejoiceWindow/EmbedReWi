import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as e,a as n,b as s,w as i,r as p,o as d,e as c}from"./app-DIMvcjhy.js";const l="/assets/IIC_data_validity-DfpbFM6b.png",h="/assets/IIC_start_stop-tRkhXUjf.png",b="/assets/IIC_Byte_format-CrzzzvQo.png",f="/assets/IIC_send_data-Bpaae9Xg.png",g="/assets/IIC_receive_data-Ba_KPTaR.png",C="/assets/IIC_ack-DIR-jSvI.png",I="/assets/7-bit_device-C6-QuEbV.png",S="/assets/7-bit_structure-DA9KOu2E.png",m="/assets/Host_write-Slave_receive-DA8pLj73.png",_="/assets/Host_read-Slave_send-CcZ57Rxo.png",A="/assets/10-bit_Write-BYqGG9Li.png",u="/assets/10-bit_Read-vz1I24b7.png",y={};function x(D,t){const a=p("RouteLink");return d(),o("div",null,[t[1]||(t[1]=e('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><div class="hint-container tip"><p class="hint-container-title">I2C（Inter-Integrated Circuit）</p><p><sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup> <sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup></p><p>IIC（Inter-Integrated Circuit）是 IIC Bus 简称，中文叫集成电路总线。由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。<br> I2C（Inter-Integrated Circuit）是一种串行通信协议，也称为IIC（Inter-IC、Inter IC BUS）总线，用于连接微控制器（MCU）与外部设备，如传感器、存储器、显示器等。</p><p>它是一种半双工通信协议，支持多主机和多从机模式。</p><p>在I2C总线上，可以同时连接多个设备，每个设备都有一个唯一的地址，用于在总线上唯一识别该设备。</p><p>由于存在时钟线，所以单片机随时可以暂停传输去处理中断的事情。</p><p>两根通信线：SCL(Serial Clock)、SDA(Serial Data)</p></div><p>IIC总线上所有器件都具有“自动应答”功能，保证数据传输的正确性； 主机和从机的区别在于对SCL的发送权，只有主机才能发送SCL；<br> IIC中，<strong>任何时候都是主机（CPU）完全掌控SCL线</strong>，在空闲状态下，主机可以主动发起对SDA线的控制，只有在<strong>从机发送数据（主机发送读取从机命令之后）和从机应答</strong>的时候，主机才会转交SDA的控制权给从机。</p><p>一主多从模式：只有一个主设备（通常是微控制器）控制整个通信过程，可以与多个从设备进行通信。主设备负责发送起始条件、设备地址以及读写指令，从而选择特定的从设备进行数据交换。其他从设备则根据其地址是否匹配来决定是否响应主设备的通信请求。</p><p>多主多从模式： 在多主多从模式下，除了多个从设备之外，还可以有多个主设备连接到同一条I2C总线上。不同主设备之间会通过仲裁机制来协调总线的访问权，避免通信冲突和数据丢失。当一个主设备想要访问总线上的某个从设备时，它必须首先获得总线的控制权，其他主设备则处于被动监听状态。</p><p>任何时刻都只存在简单的主从关系，按数据传输的方向，主机可以是主发送器或主接收器；<br> 支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；</p><table><thead><tr><th>模式</th><th>速度</th></tr></thead><tbody><tr><td>标准模式（Standard Mode）</td><td>100KHz 100kb/s</td></tr><tr><td>快速模式（Fast Mode）</td><td>400KHz 400kb/s</td></tr><tr><td>增强快速模式（Fast Mode Plus）</td><td>1Mb/s</td></tr><tr><td>高速模式（High Speed Mode）</td><td>3.4Mb/s</td></tr><tr><td>极速模式（Ultra-FastMode）</td><td>5Mb/s</td></tr></tbody></table><h2 id="硬件电路设计" tabindex="-1"><a class="header-anchor" href="#硬件电路设计"><span>硬件电路设计</span></a></h2>',8)),n("p",null,[s(a,{to:"/hardware/IIC%E6%8E%A5%E5%8F%A3.html"},{default:i(()=>t[0]||(t[0]=[c("参考硬件部分")])),_:1})]),t[2]||(t[2]=e('<h2 id="软件时序设计" tabindex="-1"><a class="header-anchor" href="#软件时序设计"><span>软件时序设计<sup class="footnote-ref"><a href="#footnote1">[1:1]</a><a class="footnote-anchor" id="footnote-ref1:1"></a></sup></span></a></h2><p>在I2C通信中，每个从设备都必须有一个唯一的7位地址，其中最高位是固定的0，剩余的7位由设备厂商指定。主设备使用这个地址来选择要与之通讯的特定从设备。</p><p>在I2C通信中，每个字节都由8位组成，读/写位是通过最低位（LSB）来指示的，其中0表示写入（Write），1表示读取（Read）。</p><p>因此，将从设备的7位地址左移一位，并附加读/写位，可以生成8位地址字节。对于一个从设备地址为0x50的设备，如果要向其写入数据，则需要将其地址左移一位，并附加写入位0，生成8位地址字节0xA0；如果要从该设备读取数据，则需要将其地址左移一位，并附加读取位1，生成8位地址字节0xA1。</p><h3 id="数据有效性" tabindex="-1"><a class="header-anchor" href="#数据有效性"><span>数据有效性</span></a></h3><p>IIC 的数据读取动作都在 SCL为高 时产生，SCL为低时是数据改变的时期，无论SDA如何变化都不影响读取。所以，传输数据的过程中，当SCL为高时，数据应当保持稳定，避免数据的采集出错。</p><figure><img src="'+l+'" alt="data_validity" tabindex="0" loading="lazy"><figcaption>data_validity</figcaption></figure><h3 id="开始和结束信号" tabindex="-1"><a class="header-anchor" href="#开始和结束信号"><span>开始和结束信号</span></a></h3><p>开始信号（START/S）： SCL为高时，SDA从高到低的跳变产生开始信号<br>    结束信号（STOP/P） ： SCL为高时，SDA从低到高的跳变产生结束信号</p><figure><img src="'+h+'" alt="start stop" tabindex="0" loading="lazy"><figcaption>start stop</figcaption></figure><p><strong>起始条件</strong>：<br> 刚开始在上拉电阻的作用下，两条总线都处于高电平，当主机进行收发时，先让SDA产生一个下降沿，当从机捕获到SCL高电平，SDA下降沿时，会进行自身的复位，等待主机召唤。<br> 在SDA下降沿之后，主机会让SCL变成低电平，一方面是占用这个总线，另一方面是为了进行拼接。因为除了起始和终止条件，每个时序单元的SCL都是低电平开始低电平结束。<br><strong>终止条件</strong>同理。</p><h3 id="重复开始信号" tabindex="-1"><a class="header-anchor" href="#重复开始信号"><span>重复开始信号</span></a></h3><p>重复开始信号（ReSTART/Sr）： 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代</p><h3 id="字节格式" tabindex="-1"><a class="header-anchor" href="#字节格式"><span>字节格式</span></a></h3><p>SDA数据线上的每个字节<strong>必须是8位</strong>，对于每次传输的<strong>字节数没有限制</strong>。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：<strong>高位在前</strong> 。<br><img src="'+b+'" alt="Byte_format" loading="lazy"></p><h3 id="发送一个字节" tabindex="-1"><a class="header-anchor" href="#发送一个字节"><span>发送一个字节</span></a></h3><figure><img src="'+f+'" alt="send data" tabindex="0" loading="lazy"><figcaption>send data</figcaption></figure><p>在SCL低电平时，允许改变SDA的电平。<br> 序号1：<br> 起始条件之后第一个字节必须是主机发送的，在SCL低电平时，主机如果想发送0就拉低电平，想发送1就拉高电平。在这一位放好之后，主机松手时钟线，SCL回弹到高电平，在高电平期间是从机读取SDA的时候，所以SCL高电平期间不允许改变SDA电平，这也是SCL高电平SDA下降沿作为起始条件的原因，因为发送数据过程中SCL高电平的话SDA肯定不会改变。</p><p>序号2：<br> SCL处于高电平之后，从机需要尽快读取SDA，一般在SCL上升沿时刻，从机就已经读取完了，因为SCL是主机控制的，从机并不知道持续多久，所以尽快读取。</p><p>之后主机拉低SCL，在下降沿之后进行下一位的传输，不过主机有SCL的主导权，不需要着急将数据写入，只需要在SCL低电平期间传输就好。</p><p>另外由于时钟线SCL进行同步，所以如果主机一个字节发送一半突然进中断，那么SCL低电平就会被不断拉长，SDA和SCL电平暂停变化，等处理结束继续操作。</p><h3 id="接收一个字节" tabindex="-1"><a class="header-anchor" href="#接收一个字节"><span>接收一个字节</span></a></h3><figure><img src="'+g+'" alt="receive data" tabindex="0" loading="lazy"><figcaption>receive data</figcaption></figure><p>虚线代表从机的电平变化。<br> 原理与发送一致，都是高位先行，只是低电平变成从机发数据，高电平主机读数据。<br> 主机在接收之前，需要释放SDA。可以理解成所有设备包括主机都处于输入模式，谁需要输出就将SDA线电平拉低。</p><h3 id="发送应答和接收应答" tabindex="-1"><a class="header-anchor" href="#发送应答和接收应答"><span>发送应答和接收应答</span></a></h3><figure><img src="'+C+'" alt="ack" tabindex="0" loading="lazy"><figcaption>ack</figcaption></figure><p>I2C通信的发送和应答机制是主从设备之间通过发送数据和应答信号来确认通信的进行，确保数据的正确传输。</p><p>发送和应答机制和发送与接收字节的原理一样，只是变成了发送一位数据。<br> 如接收应答所示，如果主机发送完字节后，要确定从机是否接收到数据，那么就要将主机切换成输入模式。此时主机立即拉高SDA电平（释放SDA控制权），从机立刻拉低SDA电平获得控制权，所以主机接收到的是从机拉低后的低电平，这就是数据0表示应答的原因。</p><p>发送应答也是同理，如果主机非应答说明主机不想要这个数据，从机就得交出SDA控制权。<br> 在时序图上，主机拉高SDA电平的瞬间就被从机拉低，所以这个过程呈现出一直是低电平的现象。</p><p>协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。主机产生数据传输过程中的所有时钟，包括<strong>用于应答的第9个时钟</strong>。发送器在应答时钟周期内释放对SDA总线的控制，这样接收器可以通过将SDA线拉低告知发送器：数据已被成功接收。<br>   应答信号分为两种：<br>     1）当第9位(应答位)为 <strong>低电平</strong> 时，为 <strong>ACK</strong>  （Acknowledge）   信号<br>     2）当第9位(应答位)为 <strong>高电平</strong> 时，为 <strong>NACK</strong>（Not Acknowledge）信号<br>   主机发送数据，从机接收时，ACK信号由从机发出。当在SCL第9位时钟高电平信号期间，如果SDA仍然保持高电平，则主机可以直接产生STOP条件终止以后的传输或者继续ReSTART开始一个新的传输<br>   从机发送数据，主机读取数据时，ACK信号由主机给出。主机响应ACK表示还需要再接收数据，而当主机接收完想要的数据后，通过发送NACK告诉从机读取数据结束、释放总线。随后主机发送STOP命令，将总线释放，结束读操作。</p><h3 id="指定地址写" tabindex="-1"><a class="header-anchor" href="#指定地址写"><span>指定地址写</span></a></h3><p>SDA先拉低电平，SCL接着拉低电平表示开始传输数据。<br> 先发送7位的从机地址，再发送读写位，表示接下来是读数据（1）还是写入数据（0）。<br> 应答位理应先让主机拉高电平放弃控制权，再让从机拉低获得SDA控制权，但图中一直是低电平，原因是主机刚拉高的瞬间就被从机拉低，所以显示一直低电平。<br> 由于应答位给了0，所以主机继续发送数据，发送的是寄存器地址，就可以送到指定设备的内部了。<br> 发送完寄存器地址之后应答位还是0，于是继续发送7位数据加上1位读写位。<br> 应答位为0，然后进入终止位。SCL先拉高，再拉高SDA。</p><h3 id="当前地址读" tabindex="-1"><a class="header-anchor" href="#当前地址读"><span>当前地址读</span></a></h3><p>由于读写位是1，接下来是读数据，从机控制SDA，主机读取，由于读数据是立马执行的，但是并没有指定寄存器地址，主机该从什么寄存器开始读取呢？</p><p>原来所有的寄存器地址存放在一个线性表中，有个地址指针指向线性表中的0位，每次写入和读取一位数据时，指针自增1位。如果在读之前，指针指向0x19，那么在本次当前地址读过程中的写入之后，当前指针指向0x19。</p><h3 id="指定地址读" tabindex="-1"><a class="header-anchor" href="#指定地址读"><span>指定地址读</span></a></h3><p>之所以能实现指定地址读是因为前半部分是由指定地址写的发送从机地址和发送寄存器地址组成，<br> 后半部分由当前地址读的时序。</p><p>由于前半部分指定了当前地址，后半部分读取，就实现了指定地址读。</p><h2 id="_7-bit-设备的数据传输" tabindex="-1"><a class="header-anchor" href="#_7-bit-设备的数据传输"><span>7-bit 设备的数据传输</span></a></h2><p>一个完整的7-bit通信过程如图所示：<br><img src="'+I+'" alt="7bit" loading="lazy"><br> 在START信号后的首字节由7位从机地址和1位读写位组成，结构如下图：<br><img src="'+S+'" alt="7-bit_structure" loading="lazy"><br> 发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由master来决定如何处理（STOP或ReSTART）。</p><h3 id="_1-主机写-从机收-传输方向不变" tabindex="-1"><a class="header-anchor" href="#_1-主机写-从机收-传输方向不变"><span>1. 主机写-从机收，传输方向不变</span></a></h3><p>主机对从机发送数据时，主机对从机发送一个开始字节，然后即可一直发送数据。以示例来讲解，其第一帧数据为要操作的寄存器地址，所以为：“[1-Byte]开始字节(写) + [1-Byte]寄存器地址 + [1-Byte]寄存器数据”。<br><img src="'+m+'" alt="Host_write-Slave_receive" loading="lazy"></p><h3 id="_2-主机读-从机发-传输方向改变" tabindex="-1"><a class="header-anchor" href="#_2-主机读-从机发-传输方向改变"><span>2. 主机读-从机发，传输方向改变</span></a></h3><p>主机对向从机读取数据时，方式同发送数据有所不同，要多一次通信过程。<br>   主机需要先向从机发送一次信号，告诉从机”我要读取数据“，然后重开一次通信，等待从机主动返回数据。以示例来讲解，发送 “[1-Byte]开始字节(写) + [1-Byte]要读取的寄存器的地址”，之后结束通信，或者重开始，来进入到第二次通信中，先发送 [1-Byte]开始字节(读)，然后等待读取从机发送过来的 [1-Byte]数据 即可。<br><img src="'+_+'" alt="Host_read-Slave_send" loading="lazy"></p><h2 id="_10-bit-设备的数据传输" tabindex="-1"><a class="header-anchor" href="#_10-bit-设备的数据传输"><span>10-bit 设备的数据传输</span></a></h2><p>随着IIC设备日益增多，7位的从机地址逐渐不能满足使用，于是从机地址从7位扩充到了10位。7位和10位地址的设备可以共存于同一个I2C总线系统互不冲突，展现了良好的兼容性。<br>   10-bit 地址的IIC设备需要 2-Byte 来传输从设备地址信息，所以采用了这样的设计：第一个字节为 1111 0 + 地址高两位(第10、9bit) + 读写控制位，第二个字节为从设备地址低8位，除此之外与7-bit设备相同。因为 “1111 0xx” 为 IIC 中特地保留的16个特殊指令地址中的一个，所以7-bit设备不会响应该首字节的呼叫，只有10-bit设备会响应，从而实现良好兼容。</p><h3 id="_1-10-bit-设备的写" tabindex="-1"><a class="header-anchor" href="#_1-10-bit-设备的写"><span>1. 10-bit 设备的写</span></a></h3><p>10-bit设备的写过程如下图示例，除地址部分外与7-bit相同。<br><img src="'+A+'" alt="10-bit_Write" loading="lazy"></p><h3 id="_2-10-bit-设备的读" tabindex="-1"><a class="header-anchor" href="#_2-10-bit-设备的读"><span>2. 10-bit 设备的读</span></a></h3><p>10-bit设备的读过程如下图示例，需注意的是，第二次通信过程无需再次发送第2Byte地址。<br><img src="'+u+'" alt="10-bit_Read" loading="lazy"></p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="footnote1" class="footnote-item"><p><a href="https://blog.csdn.net/weixin_44115575/article/details/136713792" target="_blank" rel="noopener noreferrer">IIC通讯协议详解（电路和时序图）</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a> <a href="#footnote-ref1:1" class="footnote-backref">↩︎</a></p></li><li id="footnote2" class="footnote-item"><p><a href="https://blog.csdn.net/qq_39829913/article/details/104718185" target="_blank" rel="noopener noreferrer">基础通信协议之 IIC (I2C) 详细讲解</a> <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p></li></ol></section>',53))])}const z=r(y,[["render",x]]),B=JSON.parse('{"path":"/protocol/IIC%E9%80%9A%E4%BF%A1.html","title":"IIC通信","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"IIC通信","description":"IIC通信","icon":"lucide:circuit-board","tag":["IIC","I2C"],"category":["protocol"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"IIC通信\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-05-01T08:33:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ReWi\\",\\"url\\":\\"https://gitee.com/re-wi\\",\\"email\\":\\"RejoiceWindow@yeah.net\\"},{\\"@type\\":\\"Person\\",\\"name\\":\\"ReWi\\",\\"url\\":\\"https://github.com/Re-Wi/\\",\\"email\\":\\"RejoiceWindow@yeah.net\\"},{\\"@type\\":\\"Person\\",\\"name\\":\\"RejoiceWindow\\"}]}"],["meta",{"property":"og:url","content":"https://em.rewi.xyz/protocol/IIC%E9%80%9A%E4%BF%A1.html"}],["meta",{"property":"og:site_name","content":"EmbedReWi"}],["meta",{"property":"og:title","content":"IIC通信"}],["meta",{"property":"og:description","content":"IIC通信"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-01T08:33:42.000Z"}],["meta",{"property":"article:tag","content":"I2C"}],["meta",{"property":"article:tag","content":"IIC"}],["meta",{"property":"article:modified_time","content":"2025-05-01T08:33:42.000Z"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://em.rewi.xyz/rss.xml","title":"EmbedReWi RSS Feed"}]]},"git":{"createdTime":1744711098000,"updatedTime":1746088422000,"contributors":[{"name":"ReWi","username":"","email":"RejoiceWindow@yeah.net","commits":5}]},"readingTime":{"minutes":12.28,"words":3684},"filePathRelative":"protocol/IIC通信.md","localizedDate":"2025年4月15日","excerpt":"<h2>简介</h2>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">I2C（Inter-Integrated Circuit）</p>\\n<p><sup class=\\"footnote-ref\\"><a href=\\"#footnote1\\">[1]</a><a class=\\"footnote-anchor\\" id=\\"footnote-ref1\\"></a></sup> <sup class=\\"footnote-ref\\"><a href=\\"#footnote2\\">[2]</a><a class=\\"footnote-anchor\\" id=\\"footnote-ref2\\"></a></sup></p>\\n<p>IIC（Inter-Integrated Circuit）是 IIC Bus 简称，中文叫集成电路总线。由飞利浦公司在1980年代为了让主板、嵌入式系统或手机用以连接低速周边设备而发展。<br>\\nI2C（Inter-Integrated Circuit）是一种串行通信协议，也称为IIC（Inter-IC、Inter IC BUS）总线，用于连接微控制器（MCU）与外部设备，如传感器、存储器、显示器等。</p>\\n<p>它是一种半双工通信协议，支持多主机和多从机模式。</p>\\n<p>在I2C总线上，可以同时连接多个设备，每个设备都有一个唯一的地址，用于在总线上唯一识别该设备。</p>\\n<p>由于存在时钟线，所以单片机随时可以暂停传输去处理中断的事情。</p>\\n<p>两根通信线：SCL(Serial Clock)、SDA(Serial Data)</p>\\n</div>"}');export{z as comp,B as data};
