import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as t,a as s,e as a,b as h,w as r,r as k,o as d}from"./app-DIMvcjhy.js";const p={};function o(g,i){const n=k("RouteLink");return d(),e("div",null,[i[4]||(i[4]=t(`<h2 id="c语言中不能直接使用-作为变量名的一部分" tabindex="-1"><a class="header-anchor" href="#c语言中不能直接使用-作为变量名的一部分"><span>C语言中不能直接使用<code>-</code>作为变量名的一部分</span></a></h2><p><code>-</code>是一个运算符，表示减法或负号。如果允许变量名中包含<code>-</code>，编译器将无法区分它是一个变量名的一部分还是一个运算符。</p><h3 id="c-语言中的特殊情况" tabindex="-1"><a class="header-anchor" href="#c-语言中的特殊情况"><span>C 语言中的特殊情况</span></a></h3><p>虽然 C 语言也不允许变量名中直接包含 -，但在某些情况下，你可能会看到类似以下的代码：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MY</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">VAR </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里需要注意的是，MY-VAR 并不是变量，而是一个宏定义。宏定义是预处理器指令，不属于 C 语言的变量命名规则范围。编译器在预处理阶段会将 MY-VAR 替换为 42，因此不会引发冲突。</p><h2 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量"><span>局部变量</span></a></h2><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>在C语言中，局部变量是指在函数内部或代码块（如{}定义的复合语句）中定义的变量。它们的作用域、生命周期和存储位置与全局变量有显著区别。</p></div><p>在C语言中，<strong>局部变量</strong>是指在函数内部或代码块（如<code>{}</code>定义的复合语句）中定义的变量。它们的作用域、生命周期和存储位置与全局变量有显著区别。以下是关于局部变量的详细说明：</p><ul><li><strong>局部变量</strong>是C语言中用于函数内部或代码块内的临时数据存储，具有<strong>有限的作用域和生命周期</strong>，存储在栈中。</li><li>正确使用局部变量可以提高代码的模块化和安全性，避免全局变量带来的副作用（如意外修改）。</li><li>需注意局部变量的初始化、作用域覆盖以及与静态局部变量的区别。</li></ul><p>如果需要进一步探讨其他特性（如静态局部变量、跨文件变量共享等）</p><hr><h3 id="_1-定义位置" tabindex="-1"><a class="header-anchor" href="#_1-定义位置"><span><strong>1. 定义位置</strong></span></a></h3><ul><li><p><strong>定义位置</strong>：局部变量必须在函数内部或代码块内部定义。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> myFunction</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> localVar;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 局部变量，作用域仅限于myFunction函数内</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_2-作用域" tabindex="-1"><a class="header-anchor" href="#_2-作用域"><span><strong>2. 作用域</strong></span></a></h3><ul><li><p><strong>作用域</strong>：局部变量的作用域仅限于其定义的位置到所在代码块的结束位置。</p><ul><li>如果在函数内部定义，作用域是整个函数。</li><li>如果在代码块（如<code>if</code>、<code>for</code>、<code>while</code>或<code>{}</code>内）中定义，则作用域仅限于该代码块。</li></ul><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> example</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">          // 作用域是整个example函数</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">      // 作用域仅限于这个if代码块</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // 可以访问a和b</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 这里无法访问b，但可以访问a</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_3-生命周期" tabindex="-1"><a class="header-anchor" href="#_3-生命周期"><span><strong>3. 生命周期</strong></span></a></h3><ul><li><p><strong>生命周期</strong>：局部变量的生命周期从其定义的位置开始，到包含它的代码块或函数执行结束时终止。</p><ul><li>每次进入函数或代码块时，局部变量会被重新创建并分配内存。</li><li>函数或代码块执行结束后，局部变量会被销毁，内存空间被释放。</li></ul><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 每次调用func时，x会被重新初始化为5</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 函数结束后，x的内存被释放</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_4-存储位置" tabindex="-1"><a class="header-anchor" href="#_4-存储位置"><span><strong>4. 存储位置</strong></span></a></h3>`,22)),s("ul",null,[s("li",null,[i[2]||(i[2]=s("p",null,[s("strong",null,"存储位置"),a("：局部变量通常存储在**栈（Stack）**中。")],-1)),i[3]||(i[3]=s("ul",null,[s("li",null,"栈是一种后进先出（LIFO）的内存区域，用于存储函数调用的上下文信息（如参数、返回地址和局部变量）。"),s("li",null,"栈属于**主内存（RAM）**的一部分。"),s("li",null,"栈的访问速度较快，但容量有限。")],-1)),s("p",null,[i[1]||(i[1]=a("更多参考：")),h(n,{to:"/hardware/%E5%AD%98%E5%82%A8%E5%99%A8%E4%BB%B6.html"},{default:r(()=>i[0]||(i[0]=[a("存储器件")])),_:1})])])]),i[5]||(i[5]=t(`<hr><h3 id="_2-局部变量的存储机制" tabindex="-1"><a class="header-anchor" href="#_2-局部变量的存储机制"><span><strong>2. 局部变量的存储机制</strong></span></a></h3><ul><li><p><strong>默认存储位置</strong>：</p><ul><li><strong>栈（Stack）</strong>：局部变量默认使用 <code>auto</code> 存储类别，其内存由编译器自动分配和释放。</li><li><strong>生命周期</strong>：局部变量的生命周期与函数或代码块的执行时间一致，函数返回后栈空间自动释放。</li><li><strong>存储结构</strong>：栈遵循**后进先出（LIFO）**原则，每次函数调用时，栈会为局部变量分配一块连续的内存空间（栈帧）。</li></ul></li><li><p><strong>例外情况</strong>：</p><ul><li><strong>静态局部变量</strong>：若用 <code>static</code> 关键字修饰，局部变量会被存储在<strong>静态存储区（Static Storage Area）</strong>，属于RAM中的非易失性区域，生命周期为程序运行全程。</li><li><strong>寄存器变量</strong>：若用 <code>register</code> 关键字建议，局部变量可能被存储在CPU的**寄存器（Registers）**中，以提高访问速度，但这由编译器决定，不保证实现。</li></ul></li><li><p><strong>默认情况下</strong>：C语言的局部变量存储在<strong>栈（Stack）中</strong>，属于主内存（RAM）的DRAM部分。</p></li><li><p><strong>特殊存储</strong>：</p><ul><li>静态局部变量存储在静态存储区（RAM的Data Segment）。</li><li>寄存器变量可能存储在CPU的寄存器（SRAM）中。</li></ul></li><li><p><strong>硬件特性</strong>：RAM的易失性决定了局部变量在程序结束或函数返回后会被清除。</p></li></ul><table><thead><tr><th><strong>关键字</strong></th><th><strong>适用性</strong></th><th><strong>默认存储类别</strong></th><th><strong>存储位置</strong></th><th><strong>生命周期</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>局部变量</td><td>是</td><td>栈（Stack）</td><td>函数/代码块执行期间</td></tr><tr><td><code>static</code></td><td>局部变量</td><td>否</td><td>静态存储区</td><td>程序运行全程</td></tr><tr><td><code>register</code></td><td>局部变量</td><td>否</td><td>寄存器（可能）</td><td>函数/代码块执行期间</td></tr><tr><td><code>extern</code></td><td>局部变量</td><td>否</td><td>不适用</td><td>全局变量的生命周期</td></tr></tbody></table><hr><h3 id="_5-初始化与默认值" tabindex="-1"><a class="header-anchor" href="#_5-初始化与默认值"><span><strong>5. 初始化与默认值</strong></span></a></h3><ul><li><p><strong>未初始化的局部变量</strong>：如果局部变量未显式初始化，其值是<strong>未定义的</strong>（即随机值）。</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> uninitializedVar;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 值是随机的，可能引发未定义行为</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, uninitializedVar);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 风险操作</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>建议</strong>：始终显式初始化局部变量以避免未定义行为。</p></li></ul><hr><h3 id="_6-与全局变量的区别" tabindex="-1"><a class="header-anchor" href="#_6-与全局变量的区别"><span><strong>6. 与全局变量的区别</strong></span></a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>局部变量</strong></th><th><strong>全局变量</strong></th></tr></thead><tbody><tr><td><strong>定义位置</strong></td><td>函数或代码块内部</td><td>函数外部</td></tr><tr><td><strong>作用域</strong></td><td>仅限定义的函数或代码块</td><td>整个源文件（或跨文件，需用<code>extern</code>声明）</td></tr><tr><td><strong>生命周期</strong></td><td>函数/代码块执行期间</td><td>程序开始到结束</td></tr><tr><td><strong>存储位置</strong></td><td>栈（Stack）</td><td>静态数据区（Data Segment）</td></tr><tr><td><strong>默认初始化</strong></td><td>无（未初始化值随机）</td><td>默认初始化为0（未显式赋值时）</td></tr></tbody></table><hr><h3 id="_8-注意事项" tabindex="-1"><a class="header-anchor" href="#_8-注意事项"><span><strong>8. 注意事项</strong></span></a></h3><ol><li><p><strong>同名变量的覆盖</strong>：</p><ul><li>如果局部变量与全局变量同名，局部变量会<strong>屏蔽</strong>全局变量（在局部作用域内访问的是局部变量）。</li></ul><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> globalVar </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 全局变量</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> func</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> globalVar </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 20</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 局部变量，覆盖全局变量</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, globalVar);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 输出20（局部变量）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>静态局部变量</strong>：</p><ul><li>使用<code>static</code>关键字可将局部变量改为<strong>静态局部变量</strong>，其生命周期延长至程序结束，但作用域仍为局部。</li></ul><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> counter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> count </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 静态局部变量，保留上次调用的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    count</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    printf</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Count: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">%d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, count);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><hr><h2 id="悬空指针-dangling-pointer" tabindex="-1"><a class="header-anchor" href="#悬空指针-dangling-pointer"><span>悬空指针(Dangling Pointer)</span></a></h2><ul><li><strong>定义</strong>：当指针所指向的内存空间被释放或重新分配后，而指针没有被及时更新为<code>NULL</code>或指向其他合法的内存地址，就形成了悬空指针。</li><li><strong>示例</strong>：在C语言中，如下代码会产生悬空指针。</li></ul><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ptr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">malloc</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">free</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">ptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 释放内存</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 此时ptr成为悬空指针，若继续使用ptr访问内存，会导致未定义行为</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>危害</strong>：使用悬空指针会导致程序出现不可预测的结果，可能引发程序崩溃、数据损坏或安全漏洞。</li></ul><h3 id="memory-leak-内存泄露" tabindex="-1"><a class="header-anchor" href="#memory-leak-内存泄露"><span>Memory Leak（内存泄露）</span></a></h3><ul><li><strong>定义</strong>：程序在运行过程中，动态分配了内存空间，但在使用完毕后没有及时释放，导致这部分内存无法被再次利用，随着程序运行，不断积累的未释放内存会逐渐耗尽系统资源。</li><li><strong>示例</strong>：在Java中，若在一个方法中不断创建对象但没有释放，就可能导致内存泄露。</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MemoryLeakExample</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;">            byte</span><span style="--shiki-light:#E45649;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">buffer</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#C18401;--shiki-dark:#C678DD;"> byte</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1024</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1024</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 每次循环都分配1MB内存</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 这里没有释放buffer，随着循环进行，会发生内存泄露</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>危害</strong>：内存泄露会使系统可用内存逐渐减少，最终可能导致系统因内存不足而崩溃，影响系统的稳定性和可靠性。</li></ul><h3 id="两者区别" tabindex="-1"><a class="header-anchor" href="#两者区别"><span>两者区别</span></a></h3><ul><li><strong>概念不同</strong>：悬空指针是指针指向了一个已被释放或无效的内存地址；内存泄露是程序中存在未被释放的已分配内存空间。</li><li><strong>产生原因不同</strong>：悬空指针通常是在释放内存后未正确处理指针导致；内存泄露是由于程序逻辑错误，忘记释放已分配的内存，或持有不必要的对象引用使得垃圾回收器无法回收内存。</li><li><strong>影响不同</strong>：悬空指针主要危害是导致程序在访问该指针时出现错误；内存泄露主要问题是随着时间推移耗尽系统内存资源，导致系统性能下降甚至崩溃。</li></ul><h2 id="属于动态内存的数据类型" tabindex="-1"><a class="header-anchor" href="#属于动态内存的数据类型"><span>属于动态内存的数据类型</span></a></h2><ul><li><strong>数组</strong>：在C、C++等语言中，数组可以是静态分配内存，也可以是动态分配内存。当使用<code>malloc</code>、<code>calloc</code>等函数在堆上分配数组内存时，它就是动态内存分配的数组。</li><li><strong>链表</strong>：链表的节点通常是在程序运行时通过动态内存分配函数来创建和销毁的，其大小和结构可以根据需要动态改变。</li><li><strong>栈</strong>：这里指的是程序运行时的栈区，栈帧的大小在函数调用时动态分配和释放，用于存储函数的局部变量、参数等。不过，栈的管理由编译器和操作系统自动完成。</li><li><strong>堆</strong>：堆是程序运行时可以动态分配和释放内存的区域，通过<code>new</code>（C++）、<code>malloc</code>（C、C++等）等操作符来申请内存空间，用于存储各种动态数据结构。</li></ul>`,26))])}const y=l(p,[["render",o]]),u=JSON.parse('{"path":"/C/variable.html","title":"variable","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"variable","description":"变量","icon":"mdi:variable","tag":["variable"],"category":["C"],"head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"variable\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-04-16T14:39:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"ReWi\\",\\"url\\":\\"https://gitee.com/re-wi\\",\\"email\\":\\"RejoiceWindow@yeah.net\\"},{\\"@type\\":\\"Person\\",\\"name\\":\\"ReWi\\",\\"url\\":\\"https://github.com/Re-Wi/\\",\\"email\\":\\"RejoiceWindow@yeah.net\\"},{\\"@type\\":\\"Person\\",\\"name\\":\\"RejoiceWindow\\"}]}"],["meta",{"property":"og:url","content":"https://em.rewi.xyz/C/variable.html"}],["meta",{"property":"og:site_name","content":"EmbedReWi"}],["meta",{"property":"og:title","content":"variable"}],["meta",{"property":"og:description","content":"变量"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-16T14:39:03.000Z"}],["meta",{"property":"article:tag","content":"variable"}],["meta",{"property":"article:modified_time","content":"2025-04-16T14:39:03.000Z"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://em.rewi.xyz/rss.xml","title":"EmbedReWi RSS Feed"}]]},"git":{"createdTime":1744252905000,"updatedTime":1744814343000,"contributors":[{"name":"ReWi","username":"","email":"RejoiceWindow@yeah.com","commits":3}]},"readingTime":{"minutes":8.31,"words":2493},"filePathRelative":"C/variable.md","localizedDate":"2025年4月10日","excerpt":"<h2>C语言中不能直接使用<code>-</code>作为变量名的一部分</h2>\\n<p><code>-</code>是一个运算符，表示减法或负号。如果允许变量名中包含<code>-</code>，编译器将无法区分它是一个变量名的一部分还是一个运算符。</p>\\n<h3>C 语言中的特殊情况</h3>\\n<p>虽然 C 语言也不允许变量名中直接包含 -，但在某些情况下，你可能会看到类似以下的代码：</p>\\n<div class=\\"language-c line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"c\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">#define</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> MY</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">-</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">VAR </span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">42</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{y as comp,u as data};
